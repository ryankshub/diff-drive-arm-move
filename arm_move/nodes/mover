#!/usr/bin/env python3
# Mover Node
# RKS

# Project imports
from arm_move.srv import PxKinStep
from arm_move.srv import SimpleBool, SimpleBoolResponse
from arm_move.srv import ResetBox, ResetBoxResponse
# Python imports
import sys
from enum import Enum
from collections import deque
# 3rd-party imports
import geometry_msgs.msg as geomsgs
import moveit_commander
import rospy
import tf_conversions


class State(Enum):
    """
    State of the control loop. 
    REST ~ the robot is not moving
    EXEC_MOVE ~ the robot is executing a single move
    EXEC_PLAN ~ the robot is executing a plan
    """
    REST = 0
    EXEC_MOVE = 1
    EXEC_PLAN = 2


class Mover:
    """
    SERVICES:
        + reset 

        + step 

        + follow
    
    PARAMS:
        + list(x,y,z) waypoints ~ a list of 3D waypoints 
    """
    def __init__(self):
        """
        """
        # init moveit_commander and node
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node("mover")
        # params for class
        self.waypoints = rospy.get_param("/arm_move/waypoints", [])
        self._box_name = "realsense"
        self._table_name = "table"
        # moveit_objects
        group_name = "interbotix_arm"
        gripper_name = "interbotix_gripper"
        self._move_group = moveit_commander.MoveGroupCommander(group_name)
        self._gripper_group = moveit_commander.MoveGroupCommander(gripper_name)
        self._scene = moveit_commander.PlanningSceneInterface()
        self._robot = moveit_commander.RobotCommander()
        # Sleep to let visualization or gazebo finish init
        rospy.sleep(3)
        # Build box table
        self._add_table()
        # Build realsense box
        self._add_realsense_box()
        # ROS services
        self._reset_service = rospy.Service('reset', ResetBox, self._handle_reset_service)
        self._step_service = rospy.Service('step', PxKinStep, self._handle_step_service)
        self._follow_service = rospy.Service('follow', SimpleBool, self._handle_follow_service)
        # Filter waypoints
        self.waypoints = self._filter_waypoints(self.waypoints)
        configurations = self._move_group.get_named_targets()
        grip_configurations = self._gripper_group.get_named_targets()
        rospy.loginfo(f"Config point: {configurations}")
        rospy.loginfo(f"Config point: {grip_configurations}")

        # Start State and state objects
        self._state = State.REST
        self._wpt_queue = None
        self._cycle = False
        self._rotation_counter = 0

        #init node
        self._RATE = 5 # in Hz
        self._time_delta = 1./self._RATE
        rospy.Timer(rospy.Duration(self._time_delta), self.main_loop)
        rospy.spin()


    def _add_table(self):
        """
        """
        # Build box table
        TABLE_LENGTH_m = 1.5
        TABLE_WIDTH_m = 1.5
        TABLE_HEIGHT_m = 0.2
        table_pose = geomsgs.PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.z = -(.5)*TABLE_HEIGHT_m
        quads = tf_conversions.transformations.quaternion_from_euler(0,0,0)
        table_pose.pose.orientation.x = quads[0]
        table_pose.pose.orientation.y = quads[1]
        table_pose.pose.orientation.z = quads[2]
        table_pose.pose.orientation.w = quads[3]
        table_size = (TABLE_LENGTH_m, TABLE_WIDTH_m, TABLE_HEIGHT_m)
        self._scene.add_box(self._table_name, table_pose, size=table_size)
        self._wait_for_update(self._table_name, name_is_known=True)


    #TODO: This should be parsed from worlds file
    def _add_realsense_box(self, xyz=None, rpy=None):
        """
        """
        # Realsense box
        BOX_LENTH_m = 0.14
        BOX_WIDTH_m = 0.09
        BOX_HEIGHT_m = 0.05
        box_pose = geomsgs.PoseStamped()
        box_pose.header.frame_id = "world"
        # Handle position of box
        if xyz is not None:
            box_pose.pose.position.x = xyz[0]
            box_pose.pose.position.y = xyz[1]
            #Handle zed case
            if xyz[2] == 0:
                box_pose.pose.position.z = .5*BOX_HEIGHT_m
            else:
                box_pose.pose.position.z = xyz[2]
        else:
            #Initial position from gazebo world
            box_pose.pose.position.x = 0.256919
            box_pose.pose.position.y = -0.185243
            box_pose.pose.position.z = .5*BOX_HEIGHT_m
        
        # Handle orientation of box
        quads = None
        if rpy is not None:
            quads = tf_conversions.transformations.quaternion_from_euler(
                rpy[0],rpy[1],rpy[2])
        else:
            quads = tf_conversions.transformations.quaternion_from_euler(0,0,0)
        box_pose.pose.orientation.x = quads[0]
        box_pose.pose.orientation.y = quads[1]
        box_pose.pose.orientation.z = quads[2]
        box_pose.pose.orientation.w = quads[3]

        #Name and size of the box
        box_size = (BOX_LENTH_m, BOX_WIDTH_m, BOX_HEIGHT_m)
        self._scene.add_box(self._box_name, box_pose, size=box_size)
        self._wait_for_update(self._box_name, name_is_known=True)


    def _filter_waypoints(self, wpt_list):
        filtered_wpts = []
        for point in wpt_list:
            if not isinstance(point[3], bool):
                continue
            wpt_xyz = (point[0], point[1], point[2])
            self._move_group.set_position_target(wpt_xyz)
            success, _, _, _ = self._move_group.plan()
            if not success:
                continue
            filtered_wpts.append(point)
        return filtered_wpts


    def _handle_follow_service(self, req):
        # Stop robot motion
        self._state = State.REST
        self._move_group.stop()

        self._cycle = req.cycle
        self._wpt_queue = deque(self.waypoints)
        self._state = State.EXEC_PLAN
        return SimpleBoolResponse()


    def _handle_reset_service(self, req):
        # Stop robot motion
        self._state = State.REST
        self._move_group.stop()

        # Set new point for box
        new_xyz = (req.x, req.y, req.z)
        new_rpy = (req.roll, req.pitch, req.yaw)
        zero_xyz = all(v == 0 for v in new_xyz)
        zero_rpy = all(v == 0 for v in new_rpy)
        if not zero_xyz or not zero_rpy:
            #Box has new position
            self._scene.remove_world_object(name=self._box_name)
            self._add_realsense_box(xyz=new_xyz, rpy=new_rpy)
        # Set Robot to Home position
        self._move_group.set_named_target('Home')
        # Check if to clear waypoints
        if req.clear:
            self.waypoints = []
        # Update State
        self._state = State.EXEC_MOVE
        return ResetBoxResponse()

    
    def _handle_step_service(self, req):
        # Stop robot motion
        self._state = State.REST
        self._move_group.stop()
        # Read request
        pose_xyz = (req.x, req.y, req.z)
        self._move_group.set_position_target(pose_xyz)
        
        success, _, _, err_code = self._move_group.plan()

        if success:
            # If reachable, set gripper first, then move
            # Add waypoint
            self.waypoints.append([req.x, req.y, req.z, req.open])
            # Add gripper target
            if req.open:
                self._gripper_group.set_named_target('Open')
            else:
                self._gripper_group.set_named_target('Closed')
            # Add plan for state execution
            self._state = State.EXEC_MOVE

        return err_code

     
    def _wait_for_update(self, name, name_is_known=False, name_is_attached=False, timeout=3):
        start = rospy.get_time()
        seconds = rospy.get_time()
        while(seconds - start < timeout) and not rospy.is_shutdown():
            # Check if objects are in attached objects
            attached_objects = self._scene.get_attached_objects([name])
            is_attached = len(attached_objects.keys()) > 0

            #Test new objects are in the scene
            is_known = name in self._scene.get_known_object_names()

            #Test if object match state
            if (name_is_known == is_known and name_is_attached == is_attached):
                return True

            rospy.sleep(0.1)
            seconds = rospy.get_time()
        
        #Exited while loop without returning
        return False


    def main_loop(self, event):
        """
        Main execution loop of mover node

        Args:
            event: A rospy.Timer event
        """
        # Robot is not moving
        if self._state == State.REST:
            # Robot is taking a load off
            # Clear the state machine varibles
            # This is redundant, but just here for safety
            self._wpt_queue = None

        # Robot should execute go motion
        elif self._state == State.EXEC_MOVE:
            # For 'reset' and 'step' calls
            self._move_group.go(wait=True)
            self._move_group.stop()
            self._move_group.clear_pose_targets()
            self._state = State.REST

        # Robot should exection plan
        elif self._state == State.EXEC_PLAN:
            # for 'follow' service call
            # Set rotation counter
            self._rotation_counter = 0
            while True:
                # Get target
                target_pt = self._wpt_queue[0]
                # Get xyz and gripper position bool
                target_xyz = (target_pt[0], target_pt[1], target_pt[2])
                target_grip = target_pt[3]
                # Set targets
                self._move_group.set_position_target(target_xyz)
                if target_grip:
                    self._gripper_group.set_named_target('Open')
                else:
                    self._gripper_group.set_named_target('Closed')
                # Gripper cmd first
                self._gripper_group.go(wait=True)
                self._gripper_group.stop()
                self._gripper_group.clear_pose_targets()
                # Movement cmd next
                self._move_group.go(wait=True)
                self._move_group.stop()
                self._move_group.clear_pose_targets()
                # Update queue for target
                self._wpt_queue.rotate(-1)
                self._rotation_counter += 1
                # Check for kill conditions
                # If we are not in EXEC_PLAN: break loop
                if self._state != State.EXEC_PLAN:
                    break
                elif (self._rotation_counter % len(self._wpt_queue)) == 0 and not self._cycle:
                    # We only follow the path once
                    self._state = State.REST
                    break 

        # Something has gone horribly and this node should die    
        else: 
            rospy.signal_shutdown("Mover node has entered undefined state")
            exit(1)


#Activate 'mover' node for Reactive node
def main():
    """
    Main execution loop for mover node
    """
    mover = Mover()
    rospy.spin()


# Main Execution loop
if __name__ == "__main__":
    try:
        main()
    #If something kills this node, have it die
    except rospy.ROSInterruptException:
        pass
